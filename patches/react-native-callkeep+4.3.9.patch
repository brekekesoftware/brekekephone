diff --git a/node_modules/react-native-callkeep/android/src/main/java/io/wazo/callkeep/RNCallKeepModule.java b/node_modules/react-native-callkeep/android/src/main/java/io/wazo/callkeep/RNCallKeepModule.java
index 17ffe48..e7b6ec8 100644
--- a/node_modules/react-native-callkeep/android/src/main/java/io/wazo/callkeep/RNCallKeepModule.java
+++ b/node_modules/react-native-callkeep/android/src/main/java/io/wazo/callkeep/RNCallKeepModule.java
@@ -49,6 +49,7 @@ import android.telecom.PhoneAccountHandle;
 import android.telecom.TelecomManager;
 import android.telephony.TelephonyManager;
 import android.util.Log;
+import android.view.WindowManager;
 
 import com.facebook.react.bridge.Arguments;
 import com.facebook.react.bridge.Dynamic;
@@ -126,6 +127,9 @@ public class RNCallKeepModule extends ReactContextBaseJavaModule {
     private WritableNativeArray delayedEvents;
     private boolean hasListeners = false;
 
+    public static HashMap<String, Runnable> onShowIncomingCallUiCallbacks = new HashMap<String, Runnable>();
+    public static HashMap<String, Runnable> onRejectCallbacks = new HashMap<String, Runnable>();
+
     public static RNCallKeepModule getInstance(ReactApplicationContext reactContext, boolean realContext) {
         if (instance == null) {
             Log.d(TAG, "[RNCallKeepModule] getInstance : " + (reactContext == null ? "null" : "ok"));
@@ -155,7 +159,7 @@ public class RNCallKeepModule extends ReactContextBaseJavaModule {
         delayedEvents = new WritableNativeArray();
     }
 
-    private boolean isSelfManaged() {
+    private static boolean isSelfManaged() {
         try {
             return Build.VERSION.SDK_INT >= Build.VERSION_CODES.O && _settings.hasKey("selfManaged") && _settings.getBoolean("selfManaged");
         } catch (Exception e) {
@@ -209,6 +213,13 @@ public class RNCallKeepModule extends ReactContextBaseJavaModule {
             Log.w(TAG, "[RNCallKeepModule][initializeTelecomManager] no react context found.");
             return;
         }
+        initializeTelecomManager(context);
+    }
+
+    public static void initializeTelecomManager(Context context) {
+        if (telecomManager != null) {
+            return;
+        }
         ComponentName cName = new ComponentName(context, VoiceConnectionService.class);
         String appName = this.getApplicationName(context);
 
@@ -270,6 +281,9 @@ public class RNCallKeepModule extends ReactContextBaseJavaModule {
     public void registerPhoneAccount(ReadableMap options) {
         setSettings(options);
 
+        if (telephonyManager != null) {
+            return;
+        }
         if (!isConnectionServiceAvailable()) {
             Log.w(TAG, "[RNCallKeepModule] registerPhoneAccount ignored due to no ConnectionService");
             return;
@@ -306,18 +320,17 @@ public class RNCallKeepModule extends ReactContextBaseJavaModule {
         this.hasListeners = false;
     }
 
-    @ReactMethod
-    public void displayIncomingCall(String uuid, String number, String callerName) {
-        this.displayIncomingCall(uuid, number, callerName, false);
-    }
-
     @ReactMethod
     public void displayIncomingCall(String uuid, String number, String callerName, boolean hasVideo) {
         if (!isConnectionServiceAvailable() || !hasPhoneAccount()) {
             Log.w(TAG, "[RNCallKeepModule] displayIncomingCall ignored due to no ConnectionService or no phone account");
             return;
         }
+        this.staticDisplayIncomingCall(uuid, number, callerName, hasVideo);
+    }
 
+    public static void staticDisplayIncomingCall(String uuid, String number, String callerName,
+     boolean hasVideo) {
         Log.d(TAG, "[RNCallKeepModule] displayIncomingCall, uuid: " + uuid + ", number: " + number + ", callerName: " + callerName + ", hasVideo: " + hasVideo);
 
         Bundle extras = new Bundle();
@@ -376,6 +389,16 @@ public class RNCallKeepModule extends ReactContextBaseJavaModule {
 
         Log.d(TAG, "[RNCallKeepModule] startCall, uuid: " + uuid);
 
+        if (ActivityCompat.checkSelfPermission(this.getAppContext(), Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED) {
+            // TODO: Consider calling
+            //    ActivityCompat#requestPermissions
+            // here to request the missing permissions, and then overriding
+            //   public void onRequestPermissionsResult(int requestCode, String[] permissions,
+            //                                          int[] grantResults)
+            // to handle the case where the user grants the permission. See the documentation
+            // for ActivityCompat#requestPermissions for more details.
+            return;
+        }
         telecomManager.placeCall(uri, extras);
     }
 
@@ -383,20 +406,24 @@ public class RNCallKeepModule extends ReactContextBaseJavaModule {
     public void endCall(String uuid) {
         Log.d(TAG, "[RNCallKeepModule] endCall called, uuid: " + uuid);
         if (!isConnectionServiceAvailable() || !hasPhoneAccount()) {
-           Log.w(TAG, "[RNCallKeepModule] endCall ignored due to no ConnectionService or no phone account");
+            Log.w(TAG, "[RNCallKeepModule] endCall ignored due to no ConnectionService or no phone account");
             return;
         }
+        staticEndCall(uuid, this.getAppContext());
+    }
 
+    public static void staticEndCall(String uuid, Context appCtx) {
+        try {
         Connection conn = VoiceConnectionService.getConnection(uuid);
         if (conn == null) {
             Log.w(TAG, "[RNCallKeepModule] endCall ignored because no connection found, uuid: " + uuid);
             return;
         }
-        Context context = this.getAppContext();
-        AudioManager audioManager = (AudioManager) context.getSystemService(context.AUDIO_SERVICE);
-        audioManager.setMode(0);
+        AudioManager audioManager = (AudioManager) appCtx.getSystemService(appCtx.AUDIO_SERVICE);
+        audioManager.setMode(AudioManager.MODE_NORMAL);// 0
         conn.onDisconnect();
-
+        } catch (Exception e) {
+        }
         Log.d(TAG, "[RNCallKeepModule] endCall executed, uuid: " + uuid);
     }
 
@@ -404,17 +431,23 @@ public class RNCallKeepModule extends ReactContextBaseJavaModule {
     public void endAllCalls() {
         Log.d(TAG, "[RNCallKeepModule] endAllCalls called");
         if (!isConnectionServiceAvailable() || !hasPhoneAccount()) {
-            Log.w(TAG, "[RNCallKeepModule] endAllCalls ignored due to no ConnectionService or no phone account");
+            Log.w(TAG,
+             "[RNCallKeepModule] endAllCalls ignored due to no ConnectionService or no phone account");
             return;
         }
-
-        ArrayList<Map.Entry<String, VoiceConnection>> connections =
-            new ArrayList<Map.Entry<String, VoiceConnection>>(VoiceConnectionService.currentConnections.entrySet());
-        for (Map.Entry<String, VoiceConnection> connectionEntry : connections) {
-            Connection connectionToEnd = connectionEntry.getValue();
-            connectionToEnd.onDisconnect();
+        try {
+            ArrayList<Map.Entry<String, VoiceConnection>> connections =
+             new ArrayList<Map.Entry<String, VoiceConnection>>(
+              VoiceConnectionService.currentConnections.entrySet());
+            for (Map.Entry<String, VoiceConnection> connectionEntry : connections) {
+                try {
+                    Connection connectionToEnd = connectionEntry.getValue();
+                    connectionToEnd.onDisconnect();
+                } catch (Exception e) {
+                }
+            }
+        } catch (Exception e) {
         }
-
         Log.d(TAG, "[RNCallKeepModule] endAllCalls executed");
     }
 
@@ -439,83 +472,87 @@ public class RNCallKeepModule extends ReactContextBaseJavaModule {
             optionalPermsArr[i] = optionalPermissions.getString(i);
         }
 
-        final String[] allPermissions = Arrays.copyOf(permissions, permissions.length + optionalPermsArr.length);
-        System.arraycopy(optionalPermsArr, 0, allPermissions, permissions.length, optionalPermsArr.length);
+        final String[] allPermissions = Arrays.copyOf(permissions,
+         permissions.length + optionalPermsArr.length);
+        System.arraycopy(optionalPermsArr, 0, allPermissions, permissions.length,
+         optionalPermsArr.length);
 
         hasPhoneAccountPromise = promise;
 
         if (!this.hasPermissions()) {
             WritableArray allPermissionaw = Arguments.createArray();
             for (String allPermission : allPermissions) {
-               allPermissionaw.pushString(allPermission);
+                allPermissionaw.pushString(allPermission);
             }
 
             getReactApplicationContext()
-                .getNativeModule(PermissionsModule.class)
-                .requestMultiplePermissions(allPermissionaw, new Promise() {
-                    @Override
-                    public void resolve(@Nullable Object value) {
-                        WritableMap grantedPermission = (WritableMap) value;
-                        int[] grantedResult = new int[allPermissions.length];
-                        for (int i=0; i<allPermissions.length; ++i) {
-                            String perm = allPermissions[i];
-                            grantedResult[i] = grantedPermission.getString(perm).equals("granted")
-                                ? PackageManager.PERMISSION_GRANTED
-                                : PackageManager.PERMISSION_DENIED;
-                        }
-                        RNCallKeepModule.onRequestPermissionsResult(REQUEST_READ_PHONE_STATE, allPermissions, grantedResult);
-                    }
-
-                    @Override
-                    public void reject(String code, String message) {
-                        hasPhoneAccountPromise.resolve(false);
-                    }
-
-                    @Override
-                    public void reject(String code, Throwable throwable) {
-                        hasPhoneAccountPromise.resolve(false);
-                    }
-
-                    @Override
-                    public void reject(String code, String message, Throwable throwable) {
-                        hasPhoneAccountPromise.resolve(false);
-                    }
-
-                    @Override
-                    public void reject(Throwable throwable) {
-                        hasPhoneAccountPromise.resolve(false);
-                    }
-
-                    @Override
-                    public void reject(Throwable throwable, WritableMap userInfo) {
-                        hasPhoneAccountPromise.resolve(false);
-                    }
-
-                    @Override
-                    public void reject(String code, @NonNull WritableMap userInfo) {
-                        hasPhoneAccountPromise.resolve(false);
-                    }
-
-                    @Override
-                    public void reject(String code, Throwable throwable, WritableMap userInfo) {
-                        hasPhoneAccountPromise.resolve(false);
-                    }
-
-                    @Override
-                    public void reject(String code, String message, @NonNull WritableMap userInfo) {
-                        hasPhoneAccountPromise.resolve(false);
-                    }
-
-                    @Override
-                    public void reject(String code, String message, Throwable throwable, WritableMap userInfo) {
-                        hasPhoneAccountPromise.resolve(false);
-                    }
-
-                    @Override
-                    public void reject(String message) {
-                        hasPhoneAccountPromise.resolve(false);
-                    }
-            });
+             .getNativeModule(PermissionsModule.class)
+             .requestMultiplePermissions(allPermissionaw, new Promise() {
+                 @Override
+                 public void resolve(@Nullable Object value) {
+                     WritableMap grantedPermission = (WritableMap) value;
+                     int[] grantedResult = new int[allPermissions.length];
+                     for (int i = 0; i < allPermissions.length; ++i) {
+                         String perm = allPermissions[i];
+                         grantedResult[i] = grantedPermission.getString(perm).equals("granted")
+                          ? PackageManager.PERMISSION_GRANTED
+                          : PackageManager.PERMISSION_DENIED;
+                     }
+                     RNCallKeepModule.onRequestPermissionsResult(REQUEST_READ_PHONE_STATE,
+                      allPermissions, grantedResult);
+                 }
+
+                 @Override
+                 public void reject(String code, String message) {
+                     hasPhoneAccountPromise.resolve(false);
+                 }
+
+                 @Override
+                 public void reject(String code, Throwable throwable) {
+                     hasPhoneAccountPromise.resolve(false);
+                 }
+
+                 @Override
+                 public void reject(String code, String message, Throwable throwable) {
+                     hasPhoneAccountPromise.resolve(false);
+                 }
+
+                 @Override
+                 public void reject(Throwable throwable) {
+                     hasPhoneAccountPromise.resolve(false);
+                 }
+
+                 @Override
+                 public void reject(Throwable throwable, WritableMap userInfo) {
+                     hasPhoneAccountPromise.resolve(false);
+                 }
+
+                 @Override
+                 public void reject(String code, @NonNull WritableMap userInfo) {
+                     hasPhoneAccountPromise.resolve(false);
+                 }
+
+                 @Override
+                 public void reject(String code, Throwable throwable, WritableMap userInfo) {
+                     hasPhoneAccountPromise.resolve(false);
+                 }
+
+                 @Override
+                 public void reject(String code, String message, @NonNull WritableMap userInfo) {
+                     hasPhoneAccountPromise.resolve(false);
+                 }
+
+                 @Override
+                 public void reject(String code, String message, Throwable throwable,
+                  WritableMap userInfo) {
+                     hasPhoneAccountPromise.resolve(false);
+                 }
+
+                 @Override
+                 public void reject(String message) {
+                     hasPhoneAccountPromise.resolve(false);
+                 }
+             });
             return;
         }
 
@@ -535,6 +572,17 @@ public class RNCallKeepModule extends ReactContextBaseJavaModule {
         }
 
         boolean hasSim = telephonyManager.getSimState() != TelephonyManager.SIM_STATE_ABSENT;
+        if (ActivityCompat.checkSelfPermission(this.getAppContext(), Manifest.permission.READ_PHONE_STATE)
+         != PackageManager.PERMISSION_GRANTED) {
+            // TODO: Consider calling
+            //    ActivityCompat#requestPermissions
+            // here to request the missing permissions, and then overriding
+            //   public void onRequestPermissionsResult(int requestCode, String[] permissions,
+            //                                          int[] grantResults)
+            // to handle the case where the user grants the permission. See the documentation
+            // for ActivityCompat#requestPermissions for more details.
+            return;
+        }
         boolean hasDefaultAccount = telecomManager.getDefaultOutgoingPhoneAccount("tel") != null;
 
         promise.resolve(!hasSim || hasDefaultAccount);
@@ -936,22 +984,22 @@ public class RNCallKeepModule extends ReactContextBaseJavaModule {
         return this.reactContext.getCurrentActivity();
     }
 
-    private void registerPhoneAccount(Context appContext) {
-        if (!isConnectionServiceAvailable()) {
-            Log.w(TAG, "[RNCallKeepModule] registerPhoneAccount ignored due to no ConnectionService");
-            return;
+    @ReactMethod
+    public static void registerPhoneAccount(Context appContext) {
+
+      if (telephonyManager != null) {
+          return;
         }
 
-        this.initializeTelecomManager();
-        Context context = this.getAppContext();
-        if (context == null) {
-            Log.w(TAG, "[RNCallKeepModule][registerPhoneAccount] no react context found.");
+        if (!isConnectionServiceAvailable()) {
+            Log.w(TAG, "[RNCallKeepModule] registerPhoneAccount ignored due to no ConnectionService");
             return;
         }
-        String appName = this.getApplicationName(context);
-
+        initializeTelecomManager(appContext);
+        String appName = getApplicationName(appContext);
+        Log.w(TAG, "[RNCallKeepModule][registerPhoneAccount]::"+ appContext.getApplicationContext().toString());
         PhoneAccount.Builder builder = new PhoneAccount.Builder(handle, appName);
-        if (isSelfManaged()) {
+        if (_settings == null || isSelfManaged()) {
             builder.setCapabilities(PhoneAccount.CAPABILITY_SELF_MANAGED);
         }
         else {
@@ -966,7 +1014,7 @@ public class RNCallKeepModule extends ReactContextBaseJavaModule {
 
         PhoneAccount account = builder.build();
 
-        telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
+        telephonyManager = (TelephonyManager) appContext.getSystemService(Context.TELEPHONY_SERVICE);
 
         telecomManager.registerPhoneAccount(account);
     }
@@ -989,7 +1037,7 @@ public class RNCallKeepModule extends ReactContextBaseJavaModule {
         }
     }
 
-    private String getApplicationName(Context appContext) {
+    private static String getApplicationName(Context appContext) {
         ApplicationInfo applicationInfo = appContext.getApplicationInfo();
         int stringId = applicationInfo.labelRes;
 
@@ -997,7 +1045,7 @@ public class RNCallKeepModule extends ReactContextBaseJavaModule {
     }
 
     private Boolean hasPermissions() {
-        ReactApplicationContext context = getContext();
+        ReactApplicationContext context = this.reactContext;
 
         boolean hasPermissions = true;
         for (String permission : permissions) {
@@ -1010,9 +1058,9 @@ public class RNCallKeepModule extends ReactContextBaseJavaModule {
         return hasPermissions;
     }
 
-    private boolean hasPhoneAccount() {
+    private  boolean hasPhoneAccount() {
         if (telecomManager == null) {
-            this.initializeTelecomManager();
+            initializeTelecomManager();
         }
 
         if (isSelfManaged()) {
diff --git a/node_modules/react-native-callkeep/android/src/main/java/io/wazo/callkeep/VoiceConnection.java b/node_modules/react-native-callkeep/android/src/main/java/io/wazo/callkeep/VoiceConnection.java
index 1ea76fb..36b3f18 100644
--- a/node_modules/react-native-callkeep/android/src/main/java/io/wazo/callkeep/VoiceConnection.java
+++ b/node_modules/react-native-callkeep/android/src/main/java/io/wazo/callkeep/VoiceConnection.java
@@ -320,11 +320,29 @@ public class VoiceConnection extends Connection {
         }
         rejected = true;
 
+        String uuid = handle.get(EXTRA_CALL_UUID);
+        if (RNCallKeepModule.onRejectCallbacks.containsKey(uuid)) {
+            try {
+                RNCallKeepModule.onRejectCallbacks.get(uuid).run();
+            } catch (Exception ex) {
+                Log.e(TAG, "onRejectCallbacks.get(uuid).run(): " + ex.getMessage());
+                ex.printStackTrace();
+            }
+            try {
+                RNCallKeepModule.onRejectCallbacks.remove(uuid);
+            } catch (Exception ex) {}
+            try {
+                RNCallKeepModule.onShowIncomingCallUiCallbacks.remove(uuid);
+            } catch (Exception ex) {}
+        } else {
+            Log.e(TAG, "onRejectCallbacks.get(uuid).run(): runnable not found for " + uuid);
+        }
+
         setDisconnected(new DisconnectCause(DisconnectCause.REJECTED));
         sendCallRequestToActivity(ACTION_END_CALL, handle);
         Log.d(TAG, "[VoiceConnection] onReject executed");
         try {
-            ((VoiceConnectionService) context).deinitConnection(handle.get(EXTRA_CALL_UUID));
+          ((VoiceConnectionService) context).deinitConnection(uuid);
         } catch(Throwable exception) {
             Log.e(TAG, "[VoiceConnection] onReject, handle map error", exception);
         }
@@ -333,6 +351,20 @@ public class VoiceConnection extends Connection {
 
     @Override
     public void onShowIncomingCallUi() {
+      String uuid = handle.get(EXTRA_CALL_UUID);
+        if (RNCallKeepModule.onShowIncomingCallUiCallbacks.containsKey(uuid)) {
+            try {
+                RNCallKeepModule.onShowIncomingCallUiCallbacks.get(uuid).run();
+            } catch (Exception ex) {
+                Log.e(TAG, "onShowIncomingCallUiCallbacks.get(uuid).run(): " + ex.getMessage());
+                ex.printStackTrace();
+            }
+            try {
+                RNCallKeepModule.onShowIncomingCallUiCallbacks.remove(uuid);
+            } catch (Exception ex) {}
+        } else {
+            Log.e(TAG, "onShowIncomingCallUiCallbacks.get(uuid).run(): runnable not found for " + uuid);
+        }
         Log.d(TAG, "[VoiceConnection] onShowIncomingCallUi");
         sendCallRequestToActivity(ACTION_SHOW_INCOMING_CALL_UI, handle);
     }
diff --git a/node_modules/react-native-callkeep/android/src/main/java/io/wazo/callkeep/VoiceConnectionService.java b/node_modules/react-native-callkeep/android/src/main/java/io/wazo/callkeep/VoiceConnectionService.java
index f53c052..80f4c96 100644
--- a/node_modules/react-native-callkeep/android/src/main/java/io/wazo/callkeep/VoiceConnectionService.java
+++ b/node_modules/react-native-callkeep/android/src/main/java/io/wazo/callkeep/VoiceConnectionService.java
@@ -51,6 +51,8 @@ import android.util.Log;
 import com.facebook.react.HeadlessJsTaskService;
 import com.facebook.react.bridge.ReadableMap;
 import com.facebook.react.bridge.WritableMap;
+import com.facebook.react.bridge.WritableNativeArray;
+import com.facebook.react.bridge.WritableNativeMap;
 
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -121,7 +123,21 @@ public class VoiceConnectionService extends ConnectionService {
     }
 
     public static WritableMap getSettings(@Nullable Context context) {
-       WritableMap settings = RNCallKeepModule.getSettings(context);
+      //  WritableMap settings = RNCallKeepModule.getSettings(context);
+        WritableMap settings = new WritableNativeMap();
+        settings.putString("alertTitle", "Permissions required");
+        settings.putString("alertDescription", "Brekeke Phone needs to your permission to display calls");
+        settings.putString("cancelButton", "Cancel");
+        settings.putString("okButton", "OK");
+        settings.putString("imageName", "phone_account_icon");
+        settings.putArray("additionalPermissions", new WritableNativeArray());
+        settings.putBoolean("selfManaged", true);
+        WritableMap foregroundService = new WritableNativeMap();
+        foregroundService.putString("channelId", "com.brekeke.phone");
+        foregroundService.putString("channelName", "Foreground service for Brekeke Phone");
+        foregroundService.putString("notificationTitle", "Brekeke Phone is running on background");
+        foregroundService.putString("notificationIcon", "ic_launcher");
+        settings.putMap("foregroundService", foregroundService);
        return settings;
     }
 
@@ -312,18 +328,18 @@ public class VoiceConnectionService extends ConnectionService {
             .setContentTitle(foregroundSettings.getString("notificationTitle"))
             .setPriority(NotificationManager.IMPORTANCE_MIN)
             .setCategory(Notification.CATEGORY_SERVICE);
-
-        Activity currentActivity = RNCallKeepModule.instance.getCurrentReactActivity();
-        if (currentActivity != null) {
-            Intent notificationIntent = new Intent(this, currentActivity.getClass());
-            notificationIntent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);
-
-            final int flag =  Build.VERSION.SDK_INT >= Build.VERSION_CODES.M ? PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE : PendingIntent.FLAG_UPDATE_CURRENT;
-
-            PendingIntent pendingIntent = PendingIntent.getActivity(this, NOTIFICATION_ID, notificationIntent, flag);
-
-            notificationBuilder.setContentIntent(pendingIntent);
-        }
+        // ----- New logic need check later ---
+//        Activity currentActivity = RNCallKeepModule.instance.getCurrentReactActivity();
+//        if (currentActivity != null) {
+//            Intent notificationIntent = new Intent(this, currentActivity.getClass());
+//            notificationIntent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);
+//
+//            final int flag =  Build.VERSION.SDK_INT >= Build.VERSION_CODES.M ? PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE : PendingIntent.FLAG_UPDATE_CURRENT;
+//
+//            PendingIntent pendingIntent = PendingIntent.getActivity(this, NOTIFICATION_ID, notificationIntent, flag);
+//
+//            notificationBuilder.setContentIntent(pendingIntent);
+//        }
 
         if (foregroundSettings.hasKey("notificationIcon")) {
             Context context = this.getApplicationContext();
diff --git a/node_modules/react-native-callkeep/index.d.ts b/node_modules/react-native-callkeep/index.d.ts
index ee1a7fb..bf4841b 100644
--- a/node_modules/react-native-callkeep/index.d.ts
+++ b/node_modules/react-native-callkeep/index.d.ts
@@ -151,7 +151,7 @@ declare module 'react-native-callkeep' {
       uuid: string,
       displayName: string,
       handle: string,
-      options?: object,
+      iosOptions?: object,
     ): void
 
     static checkPhoneAccountEnabled(): Promise<boolean>;
diff --git a/node_modules/react-native-callkeep/index.js b/node_modules/react-native-callkeep/index.js
index 9f1312b..bbfb4c4 100644
--- a/node_modules/react-native-callkeep/index.js
+++ b/node_modules/react-native-callkeep/index.js
@@ -269,18 +269,12 @@ class RNCallKeep {
     RNCallKeepModule.setCurrentCallActive(callUUID);
   };
 
-  updateDisplay = (uuid, displayName, handle, options = null) => {
+  updateDisplay = (uuid, displayName, handle, iosOptions = {}) => {
     if (!isIOS) {
       RNCallKeepModule.updateDisplay(uuid, displayName, handle);
       return;
     }
 
-    let iosOptions = {};
-    if (options && options.ios) {
-      iosOptions = {
-        ...options.ios,
-      };
-    }
     RNCallKeepModule.updateDisplay(uuid, displayName, handle, iosOptions);
   };
 
diff --git a/node_modules/react-native-callkeep/ios/RNCallKeep/RNCallKeep.m b/node_modules/react-native-callkeep/ios/RNCallKeep/RNCallKeep.m
index e67c3cd..3a96810 100644
--- a/node_modules/react-native-callkeep/ios/RNCallKeep/RNCallKeep.m
+++ b/node_modules/react-native-callkeep/ios/RNCallKeep/RNCallKeep.m
@@ -160,6 +160,11 @@ - (void)sendEventWithNameWrapper:(NSString *)name body:(id)body {
             body, @"data",
             nil
         ];
+
+        if (_delayedEvents == nil){
+          _delayedEvents = [NSMutableArray array];
+        }
+
         [_delayedEvents addObject:dictionary];
     }
 }
@@ -169,11 +174,16 @@ + (NSDictionary *) getSettings {
 }
 
 + (void)initCallKitProvider {
-    if (sharedProvider == nil) {
-        NSDictionary *settings = [self getSettings];
-        if (settings != nil) {
-            sharedProvider = [[CXProvider alloc] initWithConfiguration:[RNCallKeep getProviderConfiguration:settings]];
-        }
+   #ifdef DEBUG
+    NSLog(@"[RNCallKeep][initCallKitProvider]");
+   #endif
+
+    if (sharedProvider == nil)
+    {
+           NSDictionary *settings = [self getSettings];
+           if (settings != nil) {
+               sharedProvider = [[CXProvider alloc] initWithConfiguration:[RNCallKeep getProviderConfiguration:settings]];
+           }
     }
 }
 
@@ -201,14 +211,23 @@ + (void)setup:(NSDictionary *)options {
     NSLog(@"[RNCallKeep][setup] options = %@", options);
 #endif
     _version = [[[NSProcessInfo alloc] init] operatingSystemVersion];
-    self.callKeepCallController = [[CXCallController alloc] init];
-
-    [self setSettings: options];
-
-    [RNCallKeep initCallKitProvider];
+    if (self.callKeepCallController == nil) {
+        self.callKeepCallController = [[CXCallController alloc] init];
+    }
+    // NSDictionary *previousSettingsStored = [[NSUserDefaults standardUserDefaults] dictionaryForKey:@"RNCallKeepSettings"];
+//    [self setSettings: options];
+    NSDictionary *previousSettingsStored = [[NSUserDefaults standardUserDefaults] dictionaryForKey:@"RNCallKeepSettings"];
+    NSDictionary *settings = [[NSMutableDictionary alloc] initWithDictionary:options];
 
-    self.callKeepProvider = sharedProvider;
-    [self.callKeepProvider setDelegate:self queue:nil];
+    // Store settings in NSUserDefault
+    [[NSUserDefaults standardUserDefaults] setObject:settings forKey:@"RNCallKeepSettings"];
+    [[NSUserDefaults standardUserDefaults] synchronize];
+    // compare config and re init callkit provider if there is delta
+    if (![previousSettingsStored isEqualToDictionary:settings]) {
+        [RNCallKeep initCallKitProvider];
+        self.callKeepProvider = sharedProvider;
+        [self.callKeepProvider setDelegate:self queue:nil];
+    }
 }
 
 RCT_EXPORT_METHOD(setSettings:(NSDictionary *)options)
@@ -216,11 +235,13 @@ + (void)setup:(NSDictionary *)options {
 #ifdef DEBUG
     NSLog(@"[RNCallKeep][setSettings] options = %@", options);
 #endif
-    NSDictionary *settings = [[NSMutableDictionary alloc] initWithDictionary:options];
 
+    NSDictionary *settings = [[NSMutableDictionary alloc] initWithDictionary:options];
     // Store settings in NSUserDefault
     [[NSUserDefaults standardUserDefaults] setObject:settings forKey:@"RNCallKeepSettings"];
     [[NSUserDefaults standardUserDefaults] synchronize];
+    // compare config and re init callkit provider if there is delta
+  
 }
 
 RCT_EXPORT_METHOD(setReachable)
@@ -320,6 +341,9 @@ + (void)setup:(NSDictionary *)options {
 #ifdef DEBUG
     NSLog(@"[RNCallKeep][startCall] uuidString = %@", uuidString);
 #endif
+    if (self.callKeepProvider == nil) {
+      [RNCallKeep initCallKitProvider];
+    }
     int _handleType = [RNCallKeep getHandleType:handleType];
     NSUUID *uuid = [[NSUUID alloc] initWithUUIDString:uuidString];
     CXHandle *callHandle = [[CXHandle alloc] initWithType:_handleType value:handle];
@@ -861,6 +885,11 @@ + (CXProviderConfiguration *)getProviderConfiguration:(NSDictionary*)settings
 #ifdef DEBUG
     NSLog(@"[RNCallKeep][getProviderConfiguration]");
 #endif
+    NSString *localizedName = @"unknown";
+    if (settings && settings[@"appName"]) {
+        localizedName = settings[@"appName"];
+    }
+
     CXProviderConfiguration *providerConfiguration = [[CXProviderConfiguration alloc] initWithLocalizedName:settings[@"appName"]];
     providerConfiguration.supportsVideo = YES;
     providerConfiguration.maximumCallGroups = 3;
@@ -876,8 +905,10 @@ + (CXProviderConfiguration *)getProviderConfiguration:(NSDictionary*)settings
     if (settings[@"maximumCallsPerCallGroup"]) {
         providerConfiguration.maximumCallsPerCallGroup = [settings[@"maximumCallsPerCallGroup"] integerValue];
     }
+    NSString *img = @"callkit.png";
     if (settings[@"imageName"]) {
-        providerConfiguration.iconTemplateImageData = UIImagePNGRepresentation([UIImage imageNamed:settings[@"imageName"]]);
+       img = settings[@"imageName"];
+      providerConfiguration.iconTemplateImageData = UIImagePNGRepresentation([UIImage imageNamed:img]);
     }
     if (settings[@"ringtoneSound"]) {
         providerConfiguration.ringtoneSound = settings[@"ringtoneSound"];
